control <- control.dcm(nsteps = 16, dt = 1, new.mod = ToyModel)
mod <- dcm(parameters, state, control)
plot(mod,y="Y")
parameters <- param.dcm(p=0.003328495,c=110.7,ddp=2.5,tau=0.51,N=100,iC=0.0196)
#parameters <- param.dcm(p=0.0009844769,c=110.7,ddp=5.87,tau=0.51,N=100,iC=0.0196)
state <- init.dcm(X=88.5,Y=11.5,xy.flow=0,yx.flow=0)
ToyModel<-function(t,state,parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dX <- -p*c*X*Y/N-(1-tau)*iC*X+(1/ddp)*Y
dY <- p*c*X*Y/N+(1-tau)*iC*X-(1/ddp)*Y
xy.flow<-p*c*X*Y/N+(1-tau)*iC*X
yx.flow<-(1/ddp)*Y
# return the rate of change
list(c(dX, dY, xy.flow,yx.flow))
})
}
control <- control.dcm(nsteps = 16, dt = 1, new.mod = ToyModel)
mod <- dcm(parameters, state, control)
plot(mod,y="Y")
parameters <- param.dcm(p=0.003328495,c=110.7,ddp=2.5,tau=0.51,N=100,iC=0.0196)
#parameters <- param.dcm(p=0.0009844769,c=110.7,ddp=5.87,tau=0.51,N=100,iC=0.0196)
#state <- init.dcm(X=88.5,Y=11.5,xy.flow=0,yx.flow=0)
state <- init.dcm(X=92.5,Y=7.5,xy.flow=0,yx.flow=0)
ToyModel<-function(t,state,parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dX <- -p*c*X*Y/N-(1-tau)*iC*X+(1/ddp)*Y
dY <- p*c*X*Y/N+(1-tau)*iC*X-(1/ddp)*Y
xy.flow<-p*c*X*Y/N+(1-tau)*iC*X
yx.flow<-(1/ddp)*Y
# return the rate of change
list(c(dX, dY, xy.flow,yx.flow))
})
}
control <- control.dcm(nsteps = 16, dt = 1, new.mod = ToyModel)
mod <- dcm(parameters, state, control)
plot(mod,y="Y")
parameters <- param.dcm(p=0.003328495,c=110.7,ddp=2.5,tau=0.51,N=100,iC=0.0196)
#parameters <- param.dcm(p=0.0009844769,c=110.7,ddp=5.87,tau=0.51,N=100,iC=0.0196)
state <- init.dcm(X=88.5,Y=11.5,xy.flow=0,yx.flow=0)
#state <- init.dcm(X=92.5,Y=7.5,xy.flow=0,yx.flow=0)
ToyModel<-function(t,state,parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dX <- -p*c*X*Y/N-(1-tau)*iC*X+(1/ddp)*Y
dY <- p*c*X*Y/N+(1-tau)*iC*X-(1/ddp)*Y
xy.flow<-p*c*X*Y/N+(1-tau)*iC*X
yx.flow<-(1/ddp)*Y
# return the rate of change
list(c(dX, dY, xy.flow,yx.flow))
})
}
control <- control.dcm(nsteps = 16, dt = 1, new.mod = ToyModel)
mod <- dcm(parameters, state, control)
plot(mod,y="Y")
(1/81.4)*((1/2.5)/(1-0.115)-(1-0.51)*0.0196/0.115)
parameters <- param.dcm(p=0.004526589,c=81.4,ddp=2.5,tau=0.51,N=100,iC=0.0196)
#parameters <- param.dcm(p=0.0009844769,c=110.7,ddp=5.87,tau=0.51,N=100,iC=0.0196)
state <- init.dcm(X=88.5,Y=11.5,xy.flow=0,yx.flow=0)
#state <- init.dcm(X=92.5,Y=7.5,xy.flow=0,yx.flow=0)
ToyModel<-function(t,state,parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dX <- -p*c*X*Y/N-(1-tau)*iC*X+(1/ddp)*Y
dY <- p*c*X*Y/N+(1-tau)*iC*X-(1/ddp)*Y
xy.flow<-p*c*X*Y/N+(1-tau)*iC*X
yx.flow<-(1/ddp)*Y
# return the rate of change
list(c(dX, dY, xy.flow,yx.flow))
})
}
control <- control.dcm(nsteps = 16, dt = 1, new.mod = ToyModel)
mod <- dcm(parameters, state, control)
plot(mod,y="Y")
parameters <- param.dcm(p=0.004526589,c=81.4,ddp=2.5,tau=0.51,N=100,iC=0.0196)
#parameters <- param.dcm(p=0.0009844769,c=110.7,ddp=5.87,tau=0.51,N=100,iC=0.0196)
state <- init.dcm(X=89,Y=11,xy.flow=0,yx.flow=0)
#state <- init.dcm(X=92.5,Y=7.5,xy.flow=0,yx.flow=0)
ToyModel<-function(t,state,parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dX <- -p*c*X*Y/N-(1-tau)*iC*X+(1/ddp)*Y
dY <- p*c*X*Y/N+(1-tau)*iC*X-(1/ddp)*Y
xy.flow<-p*c*X*Y/N+(1-tau)*iC*X
yx.flow<-(1/ddp)*Y
# return the rate of change
list(c(dX, dY, xy.flow,yx.flow))
})
}
control <- control.dcm(nsteps = 16, dt = 1, new.mod = ToyModel)
mod <- dcm(parameters, state, control)
plot(mod,y="Y")
parameters <- param.dcm(p=0.004526589,c=81.4,ddp=2.5,tau=0.51,N=128,iC=0.0196)
11.5*128/100
128-14.7
parameters <- param.dcm(p=0.004526589,c=81.4,ddp=2.5,tau=0.51,N=128,iC=0.0196)
#parameters <- param.dcm(p=0.0009844769,c=110.7,ddp=5.87,tau=0.51,N=100,iC=0.0196)
state <- init.dcm(X=113.3,Y=14.7,xy.flow=0,yx.flow=0)
#state <- init.dcm(X=92.5,Y=7.5,xy.flow=0,yx.flow=0)
ToyModel<-function(t,state,parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dX <- -p*c*X*Y/N-(1-tau)*iC*X+(1/ddp)*Y
dY <- p*c*X*Y/N+(1-tau)*iC*X-(1/ddp)*Y
xy.flow<-p*c*X*Y/N+(1-tau)*iC*X
yx.flow<-(1/ddp)*Y
# return the rate of change
list(c(dX, dY, xy.flow,yx.flow))
})
}
control <- control.dcm(nsteps = 16, dt = 1, new.mod = ToyModel)
mod <- dcm(parameters, state, control)
plot(mod,y="Y")
plot(mod,y="Y"/128)
plot(mod,y="Y/128")
7.5*128/100
128-9.6
parameters <- param.dcm(p=0.004526589,c=81.4,ddp=2.5,tau=0.51,N=128,iC=0.0196)
#parameters <- param.dcm(p=0.0009844769,c=110.7,ddp=5.87,tau=0.51,N=100,iC=0.0196)
#state <- init.dcm(X=113.3,Y=14.7,xy.flow=0,yx.flow=0)
state <- init.dcm(X=118.4,Y=9.6,xy.flow=0,yx.flow=0)
ToyModel<-function(t,state,parameters) {
with(as.list(c(state, parameters)),{
# rate of change
dX <- -p*c*X*Y/N-(1-tau)*iC*X+(1/ddp)*Y
dY <- p*c*X*Y/N+(1-tau)*iC*X-(1/ddp)*Y
xy.flow<-p*c*X*Y/N+(1-tau)*iC*X
yx.flow<-(1/ddp)*Y
# return the rate of change
list(c(dX, dY, xy.flow,yx.flow))
})
}
control <- control.dcm(nsteps = 16, dt = 1, new.mod = ToyModel)
mod <- dcm(parameters, state, control)
plot(mod,y="Y")
plot(mod,y="xy.flow")
5.5*16
1.96*16
1.96*16*128/100
runif(0.01,0.05)
runif(0.01,0.05,10)
help(runif)
runif(10,0.01,0.05)
help(rbeta)
rbeta(10,10,1)
atb<-rbeta(10,10,1)
prev<-runif(10,0.01,0.05)
prev*exp(3*atb)
plot(prev*exp(3*atb))
hist(prev*exp(3*atb))
atb<-rbeta(100,10,1)
prev<-runif(100,0.01,0.05)
hist(prev*exp(3*atb))
atb<-rbeta(1000,10,1)
prev<-runif(1000,0.01,0.05)
hist(prev*exp(3*atb))
0.9*0.1+0.1*0.5
0.9*0.9*+0.1*0.5
0.9*0.9+0.1*0.5
0.9*0.09+0.1*0.5
0.9*0.09+0.1*0.4
0.9*0.05+0.1*0.4
0.9*0.05+0.1*0.5
0.9*0.05+0.1*0.45
rbeta(100,10,1)
10/11
rbeta(100,3,1)
rbeta(100,3,0.3)
rbeta(100,10,3)
10/13
rbeta(100,3,7)
toyNet<-network.initialize(100,directed =F, bipartite=70)
library("statnet", lib.loc="~/R/win-library/3.4")
library("EpiModel", lib.loc="~/R/win-library/3.4")
library(EpiModel)
library(statnet)
toyNet<-network.initialize(100,directed =F, bipartite=70)
toy.formation <- ~edges
toy.target.stats <- c(70)
toy.coef.diss <- dissolution_coefs(dissolution = ~offset(edges), duration = 1.1)
toyEst <- netest(toyNet, toy.formation, toy.target.stats, toy.coef.diss)
param <- param.net(inf.prob = 0.004, inf.prob.m2 = 0.004,
b.rate = 0.135, b.rate.m2 = 0,
ds.rate = 0.135, ds.rate.m2 = 0,
di.rate = 0.135, di.rate.m2 = 0,
b.risk = 0.10, b.risk.m2= 0)
init <- init.net(i.num = 7, i.num.m2 = 0)
control <- control.net(type = "SI", nsims = 1, nsteps = 100, nwstats.formula = "formation", delete.nodes = T, births.FUN = bfunc, depend = TRUE,tea.status=TRUE)
bfunc <- function(dat, at) {
# Variables ---------------------------------------------------------------
b.rate <- dat$param$b.rate
b.rate.m2 <- dat$param$b.rate.m2
b.risk <- dat$param$b.risk
b.risk.m2 <- dat$param$b.risk.m2
nOld <- dat$epi$num[at - 1]
nOldM2 <- dat$epi$num.m2[at - 1]
nBirths <- nBirthsM2 <- 0
newNodes <- newNodesM2 <- NULL
# Add Nodes ---------------------------------------------------------------
nBirths <- sum(rbinom(nOld, 1, b.rate))
nBirthsM2 <- sum(rbinom(nOldM2, 1, b.rate.m2))
nCurrM1 <- length(modeids(dat$nw, 1))
nCurrM2 <- length(modeids(dat$nw, 2))
prefixes <- unique(substr(dat$nw %v% "vertex.names", 1, 1))
if (nBirths > 0) {
newNodeIDs <- (nCurrM1 + 1):(nCurrM1 + nBirths)
dat$nw <- add.vertices(dat$nw, nv = nBirths, last.mode = FALSE)
newNodes <- newNodeIDs
}
if (nBirthsM2 > 0) {
newNodeIDs <- (nCurrM2 + 1):(nCurrM2 + nBirthsM2)
dat$nw <- add.vertices(dat$nw, nv = nBirthsM2, last.mode = TRUE)
newSize <- network.size(dat$nw)
newNodesM2 <- (newSize - nBirthsM2 + 1):newSize
}
newNodes <- c(newNodes, newNodesM2)
if (!is.null(newNodes)) {
dat$nw <- activate.vertices(dat$nw, onset = at, terminus = Inf, v = newNodes)
}
# Update Nodal Attributes -------------------------------------------------
if (length(newNodes) > 0) {
newStatus <- rbinom(nBirths, 1, b.risk)
newStatus <- ifelse(newStatus == 1, "i", "s")
newStatusM2 <- rbinom(nBirthsM2, 1, b.risk.m2)
newStatusM2 <- ifelse(newStatusM2 == 1, "i", "s")
newStatus <- c(newStatus, newStatusM2)
newNodesInf <- intersect(newNodes, nCurrM1 + which(newStatus == "i"))
dat$nw <- activate.vertex.attribute(dat$nw, prefix = "testatus", value = newStatus, onset = at, terminus = Inf, v = newNodes)
dat <- split_bip(dat,"status","s",nCurrM1,nCurrM2,nBirths,nBirthsM2)
dat$attr$status[newNodesInf] <- "i"
dat <- split_bip(dat,"infTime",NA,nCurrM1,nCurrM2,nBirths,nBirthsM2)
dat$attr$infTime[newNodesInf] <- at
dat <- split_bip(dat,"active",1,nCurrM1,nCurrM2,nBirths,nBirthsM2)
dat <- split_bip(dat,"entrTime",at,nCurrM1,nCurrM2,nBirths,nBirthsM2)
dat <- split_bip(dat,"exitTime",NA,nCurrM1,nCurrM2, nBirths, nBirthsM2)
}
# Output ------------------------------------------------------------------
if (at == 2) {
dat$epi$b.flow <- c(0, nBirths)
dat$epi$b.flow.m2 <- c(0, nBirthsM2)
} else {
dat$epi$b.flow[at] <- nBirths
dat$epi$b.flow.m2[at] <- nBirthsM2
}
return(dat)
}
control <- control.net(type = "SI", nsims = 1, nsteps = 100, nwstats.formula = "formation", delete.nodes = T, births.FUN = bfunc, depend = TRUE,tea.status=TRUE)
toysim<-netsim(toyEst, param, init, control)
plot(toysim, type = "epi", popfrac=T)
plot(toysim, type = "epi", y = "si.flow")
help(matrix)
matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE,
dimnames = list(c("row1", "row2"),
c("C.1", "C.2", "C.3")))
matrix(c(70,11,3, 58,12,11, 123,11,7), nrow = 3, ncol = 3, byrow = TRUE,
dimnames = list(c("scen1", "scen2", "scen3"),
c("Not acceptable", "Acceptable under conditions", "Acceptable")))
stripps<-matrix(c(70,11,3, 58,12,11, 123,11,7), nrow = 3, ncol = 3, byrow = TRUE,
dimnames = list(c("scen1", "scen2", "scen3"),
c("Not acceptable", "Acceptable under conditions", "Acceptable")))
fisher.test(stripps)
stripps_waste<-matrix(c(28,1,0, 10,1,3), nrow = 2, ncol = 3, byrow = TRUE,
dimnames = list(c("scen1", "scen2"),
c("Not acceptable", "Acceptable under conditions", "Acceptable")))
stripps_waste
fisher.test(stripps_waste)
setwd("~/")
install.packages("devtools")
library(devtools)
install.packages("devtools")
library(devtools)
library(shiny)
runGitHub("MESuRS-Lab/mwss-App")
##sanitary context-dependent
R_C <- user(1.1) # or 0.7
#appel des packages
library(truncnorm)
# Library
library(ggplot2)
# create a dataset
data <- data.frame(
name=c( rep("A",500), rep("B",500), rep("B",500), rep("C",20), rep('D', 100)  ),
value=c( rnorm(500, 10, 5), rnorm(500, 13, 1), rnorm(500, 18, 1), rnorm(20, 25, 4), rnorm(100, 12, 1) )
)
# Most basic violin chart
p <- ggplot(data, aes(x=name, y=value, fill=name)) + # fill=name allow to automatically dedicate a color for each group
geom_violin()
#p
p
T_shift2<-14
ceiling(max(20,8)%%T_shift2/T_shift2)
ceiling(max(4,8)%%T_shift2/T_shift2)
ceiling(max(50,8)%%T_shift2/T_shift2)
T_shift2<-7
ceiling(max(50,8)%%T_shift2/T_shift2)
ceiling(max(7,8)%%T_shift2/T_shift2)
ceiling(max(8,8)%%T_shift2/T_shift2)
ceiling(max(0,8)%%T_shift2/T_shift2)
ceiling(max(1,8)%%T_shift2/T_shift2)
ceiling(max(60,8)%%T_shift2/T_shift2)
60%%4
60%%10
10%%20
60%%8
max(60,8)%%T_shift2)
max(60,8)%%T_shift2
60%%14
4/14
max(14,8)%%T_shift2
ceiling(max(14,8)%%T_shift2/T_shift2)
ceiling(max(28,8)%%T_shift2/T_shift2)
#(Simulations d') Analyses du projet d'antibior?sistance d'E.coli
#script cr?e le 24/03/2023 par Rolly Mpoyi
##data prep--------------------------------------------------------------------------------
#matrice vide
matrix <- matrix(, nrow = 10, ncol = 6)
#noms des colonnes
colnames(matrix) <- c("Isolate ID","Ampicillin (AMP)", "Ciprofloxacin (CIP)", "Azithromycin (AZI)", "Tetracycline(TET)", "Year")
#transf en data frame
matrix.df <- as.data.frame(matrix)
# ajouter les ann?es
x <- 2018:2022
#remplissage des rows  (R == 1, S == 0)
matrix.df[1,] <- c(1, 1, 1, 1, 0, sample(x, 1, replace = TRUE))
matrix.df[2,] <- c(2, 0, NA, 0, 0, sample(x, 1, replace = TRUE))
matrix.df[3,] <- c(3, 0, 0, NA, 0, sample(x, 1, replace = TRUE))
matrix.df[4,] <- c(4, 0, 0, NA, 1, sample(x, 1, replace = TRUE))
matrix.df[5,] <- c(5, 1, 1, 1, 0, sample(x, 1, replace = TRUE))
matrix.df[6,] <- c(6, 1, 1, 1, 0, sample(x, 1, replace = TRUE))
matrix.df[7,] <- c(7, 0, NA, 0, 0, sample(x, 1, replace = TRUE))
matrix.df[8,] <- c(8, 0, 0, 1, 0, sample(x, 1, replace = TRUE))
matrix.df[9,] <- c(9, 1, 0, NA, 1, sample(x, 1, replace = TRUE))
matrix.df[10,] <- c(10, 1, 0, 0, 1, sample(x, 1, replace = TRUE))
matrix.df
# data values en num?rique
matrix_num <- sapply(matrix.df, as.numeric)
matrix_num <- as.data.frame(matrix_num)
# data values as logical TRUE = resist, FALSE = sensible
matrix_logic <- matrix.df
matrix_logic <- sapply(matrix_logic[,2:5], as.logical)
matrix_logic <- as.data.frame(matrix_logic)
matrix_logic <- cbind(matrix.df[1],matrix_logic, matrix.df[6])
matrix_logic
require(dplyr)
require(tidyr)
par(mfrow = c(2,2))
hist(matrix.df$`Ampicillin (AMP)`, main = "Fr?q de res d'AMP", xlab = "Resistance (1 or 0)")
hist(matrix.df$`Ciprofloxacin (CIP)`, main = "Fr?q de res de CIP", xlab = "Resistance (1 or 0)")
hist(matrix.df$`Azithromycin (AZI)`, main = "Fr?q de res d'AZI", xlab = "Resistance (1 or 0)")
hist(matrix.df$`Tetracycline(TET)`, main = "Fr?q de res de TET", xlab = "Resistance (1 or 0)")
#nombre d'isolats test?s par ann?es
matrix_logic %>%
count(Year) -> year_count
year_count
#group? par l'ann?e, ordon?e par ann?e descendante
matrix_logic %>%
group_by(Year) %>%
arrange(desc(Year)) -> year_group
#test antibiogramme
anti_bio <- function(data, index) {  #Propre fonction cr??e (sans groupement)
#data = le data frame r?unissant toutes les donn?es
#l'indice des colonnes d'antibiotiques ? analyser
#calcul pr?valence de chaque ATB arrondi ? 2 chiffres
eSupport <- round(sapply(data[,index], mean, na.rm = TRUE),2)
#nombre d'isolats r?sistants ? chaque ATB
Nombre_Isolat <- sapply(data[,index], sum, na.rm = TRUE)
#total_isolat test?es
matrix_noNa <- !is.na(data[,index])
matrix_noNa <- as.data.frame(matrix_noNa)
Total_Isolat_test <- sapply(matrix_noNa, sum)
#cr?ation de l'antibiogramme
abg <- rbind(eSupport, Nombre_Isolat, Total_Isolat_test)
abg
}
antibiogramme <- anti_bio(matrix_logic, 2:5)
antibiogramme
antibiogram <- function(data, index, group) { #fonction reprise group?e
require(dplyr)
require(tidyr)
abgm <- group_by(data[,c(group, index)] , data[,group]) %>%
summarise_all(list(Prevalence=~mean(.,na.rm=TRUE),Number_Isolates_Tested=~sum(!is.na(.))))
overall_prev <- summarise_all(data[,c(group,index)], list(Prevalence=~mean(.,na.rm=TRUE),Number_Isolates_Tested=~sum(!is.na(.))))
overall_prev <- cbind("data[, group]"="Overall", overall_prev)
abgm <- rbind(abgm, overall_prev)
abgm <- abgm[,order(names(abgm))]
abgm
}
Year_abg <- antibiogram(matrix_logic,2:5, 6)
Year_abg
#test atb profile ie. les noms des antibiotiques test?es pour chaque isolat
atb_profile <- function(data, index){
ATB_NOMS <- names(data)[index]  #prendre les noms des ATBS qui se trouvent dans chaque isolat
atb_panels <- rep("", dim(data)[1]) #initialise un vecteur de caract?res blanc aussi long que le nombre d'isolats
for(atb in ATB_NOMS) {	#pour chaque atb
x <- with(data, get(atb)) #x est la col des valeurs pour les ATB
x <- ifelse(is.na(x), '', paste(atb, '')) #si NA, colle un espace blanc
atb_panels <- paste(atb_panels, x, sep = '') #colle la col x. pour chaque isolat, atb_panels va accumuler les noms des ATB qui ont ?t? test?s pour cet isolat
}
atb_panels #Retourne le profil test? de la sensibilit? atbiotique de chaque isolat
}
ATB_atb <- atb_profile(matrix.df,2:5)
ATB_atb
mdr_profile <- function (data, index){
#packages requis
require(stringr)
require(mgsub)
z <- data[,index] #colonne des ATBs
mdr_profile <- data.frame(Profile=rep("", dim(z)[1]), NombreRes=numeric(dim(z)[1])) #cr?ation dune df pour stocker les profils
profile <- rep("", dim(z)[1]) #Initialise un caract?re blanc aussi long que le nombre d'isolat dans le df
mdr_profile[,2] <- rowSums(z, na.rm=TRUE) #nombre de resistances aux ATBs pour chaque isolat
for(i in 1:ncol(z)) { #pour chaque ATB
z[which(z[,i]==TRUE), i] <- as.character(colnames(z)[i]) #si resistant, colle le nom de l'ATB dans la cellule
z[which(z[,i]==FALSE), i] <- as.character("") #si sensible, colle un espace blanc dans la cellule
z[is.na(z[,i]), i] <- as.character("") #ceux qui n'ont pas ?t? test?es, colle un espace blanc
profile <- paste(profile, z[,i], sep = " ") #colle tous les cols d'ATB ensemble pour avoir une chaine de caracs de tous les ATB pour lesquels chaque isolat (chaque ligne) est resistant
}
profile <- trimws(profile, which="both") #suppr les espaces blancs
mdr_profile[,1] <- profile #stocker les profils de resistance
mdr_profile #sortie
}
profil_res <- mdr_profile(matrix_logic,2:5)
profil_res
unique(profil_res) #retourne les diff?rents profils de r?sistances
#calculs ph?notype uniques, fr?q de ph?notypes
#pour chaque nombre de r?sistances aux ATBs, calcule le nombre d'isolats et de ph?notypes uniques
multi_res <- as.data.frame(table(profil_res$NombreRes)) #nombre de pattern de resistance et d'isolats
names(multi_res) <- c("NombreResATB", "NombreIsolats")
multi_res
#nombre de pattern de res uniques parmi le nombre de resistances retenu
for (i in 0:max(profil_res$NombreRes)){ #pour chauqe pattern de resistance
multi_res[i+1,3] <- nrow(unique(profil_res[which(profil_res$NombreRes==i),])) #nombre de res uniques pour  chaque profil de multi-resistances
}
names(multi_res)[3]="NombreUniqPatterns"
multi_res
rand_matrix_logic <- rep(list(matrix_logic[,2:5]),100) #copie les donn?es des ATBs
n_obs <- nrow(matrix.df) #nombre d'observations
n_nonNA <- n_obs - colSums(is.na(matrix_logic[,2:5])) #vecteur du nombre de non-NA pour chaque atb
items <- sapply(matrix_logic[,2:5], sum, na.rm=TRUE)/n_nonNA #calcul de la prevalence de chaque resistance
rand_matrix_logic
#pour chacune des 100 jeu de donnees
for (i in 1:100){ #pour chacune des 100 jeu de donnees
for (k in 1:length(items)){ #pour chaque antibiotique
bin_dat <- rbinom(n=n_nonNA[k], size=1, prob=items[k]) #valeurs binomiales ind?pendantes g?ner?es, taille = nombre de non-NA, probabilit? =% de res
rand_dat <- rand_matrix_logic[[i]][,k] #donne la col pour les ATB de la base avec les m?mes NA
rand_dat[!is.na(rand_dat)] <- bin_dat #replace les valeurs non-NA avec des valeurs binomiales ind?pendantes
rand_matrix_logic[[i]][,k] <- as.logical(rand_dat) #sauvegarde dans la base de donnees
}
}
rand_matrix_logic[[2]]
rand_matrix_logic[[3]]
rand_matrix_logic[[4]]
rand_matrix_logic[[28]]
rand_matrix_logic[[29]]
rand_matrix_logic
rand_MDRProfiles <- data.frame()
for (i in 1:100){ #pour chacunes des 100 data frame
x <- mdr_profile(rand_matrix_logic[[i]], seq(1:ncol(rand_matrix_logic[[i]])))
x <- mutate(x, db=rep(i, nrow(x))) #ajoute l'identification de la data frame
rand_MDRProfiles <- rbind(rand_MDRProfiles, x) #joint tout les profils de multi-resistance des 100 df ensembler
}
rand_MDRProfiles #profils de multi-resistance pour chaque isolat dans chaque jeu de donnees simul?s
matrix_logic
rand_matrix_logic[[29]]
mdr_profile(rand_matrix_logic[[29]],1:4)
unique(mdr_profile(rand_matrix_logic[[29]],1:4))
unique(mdr_profile(rand_matrix_logic[[28]],1:4))
library(shiny)
runGitHub("Pachka/mwss-App")
runGitHub("Pachka/mwss-App")
setwd("~/wetransfer_donnees-primo_2023-03-31_1010/EXTRACTION DATA CNAM")
data18<-read.csv("EC-2018.csv",sep=";")
data18
size(data18)
length(data18)
data18[,21]
data18[,22]
data18[,17]
data18[,10]
data18[,11]
testATB<-data18[,11:47]
testATB
testATB[is.na(testATB)] <- 0
testATB
testATB[testATB==''] <- 0
testATB
testATB[testATB=='S'] <- 1
testATB[testATB=='I'] <- 1
testATB[testATB=='R'] <- 1
testATB
unique(testATB)
ProfilsATB<-unique(testATB)
dim(ProfilsATB)
dim(testATB)
library(plyr)
count(testATB)
help("count")
testATB %>% group_by_all %>% count
data.frame(table(testATB))
library(magrittr)
testATB %>% group_by_all %>% count
library(dplyr)
testATB %>% group_by_all %>% count
colnames(testATB %>% group_by_all %>% count)
dim(testATB %>% group_by_all %>% count)
freqATB<-(testATB %>% group_by_all %>% count)
help(sort)
max(freqATB[,38])
min(freqATB[,38])
hist(freqATB[,38])
(freqATB[,38])
savehistory("~/wetransfer_donnees-primo_2023-03-31_1010/EXTRACTION DATA CNAM/codeATB.Rhistory")
